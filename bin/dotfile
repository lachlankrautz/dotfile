#!/usr/bin/env bash

# Find where we are installed through possible system links
SOURCE="${BASH_SOURCE[0]}"
# resolve $SOURCE until the file is no longer a symlink
while [ -h "${SOURCE}" ]; do
  PATH_BASE="$(cd -P "$(dirname "${SOURCE}")" && pwd)"
  SOURCE="$(readlink "${SOURCE}")"
  # if SOURCE was a relative symlink, we need to resolve it
  # relative to the path where the symlink file was located
  [[ ${SOURCE} != /* ]] && SOURCE="${PATH_BASE}/${SOURCE}"
done
PATH_BASE="$(cd -P "$(dirname "${SOURCE}")/.." && pwd)"
source "${PATH_BASE}/src/util/init.sh"

usage() {
    doc_title << 'EOF'
         __      __  _____ __
    ____/ /___  / /_/ __(_) /__
   / __  / __ \/ __/ /_/ / / _ \
  / /_/ / /_/ / /_/ __/ / /  __/
  \__,_/\____/\__/_/ /_/_/\___/

EOF
    cat << EOF
${term_fg_yellow}Usage:${term_reset}
  dotfile [options] [command]

${term_fg_yellow}Options:${term_reset}
  ${term_fg_green}-h, --help${term_reset}    Display usage
  ${term_fg_green}-v, --version${term_reset} Display version

${term_fg_yellow}Commands:${term_reset}
  ${term_fg_green}sync${term_reset}          Sync dotfiles to home dir

EOF
}

dotfile_option_v() {
    dotfile_option_version
}
dotfile_option_version() {
    echo "Version ${VERSION}"
}
dotfile_option_h() {
    HELP=1
    dispatch dotfile "$@"
}
dotfile_option_help() {
    HELP=1
    dispatch dotfile "$@"
}
dotfile_command_sync() {
    if [ ${HELP} = 0 ]; then
        source ${PATH_BASE}/src/command/sync.sh
    else
        dispatch dotfile "$@"
    fi
}
dotfile_call_() {
    BAD_CALL=1
    usage
    exit
}
dotfile_() {
    usage
}
dispatch dotfile "$@"
